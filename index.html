<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Airplane Game with Obstacle Destruction Counter</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #hud, #gameOver { position: absolute; font-family: Arial, sans-serif; color: white; }
        #hud { top: 10px; left: 10px; background-color: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; }
        #score, #timer, #altitude, #destroyedCount { margin: 5px 0; }
        #gameOver { display: none; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 24px; text-align: center; background-color: rgba(0,0,0,0.7); padding: 20px; border-radius: 10px; }
        #restartButton { margin-top: 20px; padding: 10px 20px; font-size: 18px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer; }
        #restartButton:hover { background-color: #45a049; }
    </style>
</head>
<body>
    <div id="hud">
        <div id="score">Distance: 0 m</div>
        <div id="timer">Time: 60</div>
        <div id="altitude">Altitude: 100 m</div>
        <div id="destroyedCount">Obstacles Destroyed: 0</div>
    </div>
    <div id="gameOver">
        Game Over<br>
        Final Distance: <span id="finalScore"></span> m<br>
        Obstacles Destroyed: <span id="finalDestroyedCount"></span><br>
        <button id="restartButton">Restart</button>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, airplane, obstacles = [], cloudItems = [], bullets = [], distance = 0, timeLeft = 60, gameRunning = true;
        const VERTICAL_RANGE = 20, HORIZONTAL_RANGE = 30, FORWARD_SPEED = 1.0, MOVE_SPEED = 0.2;
        let targetPosition = new THREE.Vector3(0, 10, 0), isCollided = false, timerInterval;
        let destroyedObstaclesCount = 0;

        function init() {
            setupScene();
            createEnvironment();
            createDetailedAirplane();
            scene.add(new THREE.AmbientLight(0xffffff, 0.5));
            scene.add(new THREE.DirectionalLight(0xffffff, 0.5).translateY(50));
            createInitialObstacles();
            animate();
            startTimer();
            document.addEventListener('keydown', onKeyDown);
            document.getElementById('restartButton').addEventListener('click', restartGame);
        }

        function setupScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 50, 500);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
        }

        function createEnvironment() {
            const groundGeometry = new THREE.PlaneGeometry(1000, 1000, 100, 100);
            const groundMaterial = new THREE.MeshPhongMaterial({
                color: 0x33aa33,
                wireframe: false,
                flatShading: false
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -10;
            scene.add(ground);
        }

        function createDetailedAirplane() {
            airplane = new THREE.Group();

            const fuselageGeometry = new THREE.CylinderGeometry(0.5, 0.5, 4, 32, 32);
            const fuselageMaterial = new THREE.MeshPhongMaterial({color: 0xcccccc});
            const fuselage = new THREE.Mesh(fuselageGeometry, fuselageMaterial);
            fuselage.rotation.x = Math.PI / 2;
            airplane.add(fuselage);

            const wingGeometry = new THREE.BoxGeometry(3, 0.1, 1, 10, 1, 5);
            const wingMaterial = new THREE.MeshPhongMaterial({color: 0x0000ff});
            const wing = new THREE.Mesh(wingGeometry, wingMaterial);
            wing.position.set(0, 0, 0);
            airplane.add(wing);

            const tailWingGeometry = new THREE.BoxGeometry(1.5, 0.1, 0.5, 5, 1, 3);
            const tailWing = new THREE.Mesh(tailWingGeometry, wingMaterial);
            tailWing.position.set(0, 0, 1.8);
            airplane.add(tailWing);

            const cockpitGeometry = new THREE.ConeGeometry(0.5, 1, 32);
            const cockpitMaterial = new THREE.MeshPhongMaterial({color: 0x333333});
            const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial);
            cockpit.rotation.x = -Math.PI / 2;
            cockpit.position.set(0, 0, -2.5);
            airplane.add(cockpit);

            airplane.position.set(0, 10, 0);
            scene.add(airplane);
            camera.position.set(0, 15, -20);
            camera.lookAt(airplane.position);
        }

        function createInitialObstacles() {
            for (let i = 0; i < 20; i++) {
                createDetailedObstacle(200 + i * 100);
            }
        }

        function createDetailedObstacle(zPosition) {
            const size = 5 + Math.random() * 5;
            const obstacleGeometry = new THREE.BoxGeometry(size, size, size);
            const obstacleMaterial = new THREE.MeshPhongMaterial({color: 0xff0000});
            const obstacle = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
            obstacle.position.set(
                Math.random() * HORIZONTAL_RANGE * 2 - HORIZONTAL_RANGE,
                Math.random() * VERTICAL_RANGE,
                zPosition
            );
            scene.add(obstacle);
            obstacles.push(obstacle);
        }

        function createDetailedCloud(zPosition) {
            const cloudGroup = new THREE.Group();
            const cloudMaterial = new THREE.MeshPhongMaterial({color: 0xffffff});
            for (let i = 0; i < 5; i++) {
                const cloudPartGeometry = new THREE.SphereGeometry(1 + Math.random(), 32, 32);
                const cloudPart = new THREE.Mesh(cloudPartGeometry, cloudMaterial);
                cloudPart.position.set(
                    Math.random() * 4 - 2,
                    Math.random() * 2 - 1,
                    Math.random() * 4 - 2
                );
                cloudGroup.add(cloudPart);
            }
            cloudGroup.position.set(
                Math.random() * HORIZONTAL_RANGE * 2 - HORIZONTAL_RANGE,
                Math.random() * VERTICAL_RANGE + 5,
                zPosition
            );
            scene.add(cloudGroup);
            cloudItems.push(cloudGroup);
        }

        function shootBullet() {
            const bulletGeometry = new THREE.SphereGeometry(0.2, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({color: 0xffff00});
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            
            const coneTip = new THREE.Vector3(0, 0, -3);
            coneTip.applyQuaternion(airplane.quaternion);
            coneTip.add(airplane.position);
            
            bullet.position.copy(coneTip);
            
            const direction = new THREE.Vector3(0, 0, 1);
            bullet.velocity = direction.multiplyScalar(5);
            
            scene.add(bullet);
            bullets.push(bullet);
        }

        function animate() {
            if (!gameRunning) return;
            requestAnimationFrame(animate);

            const airplaneBox = new THREE.Box3().setFromObject(airplane);
            let currentlyCollided = false;

            obstacles.forEach((obstacle, index) => {
                const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                if (airplaneBox.intersectsBox(obstacleBox)) {
                    currentlyCollided = true;
                }
                if (obstacle.position.z < airplane.position.z - 20) {
                    scene.remove(obstacle);
                    obstacles.splice(index, 1);
                    createDetailedObstacle(airplane.position.z + 500);
                }
            });

            cloudItems.forEach((cloud, index) => {
                if (cloud.position.z < airplane.position.z - 20) {
                    scene.remove(cloud);
                    cloudItems.splice(index, 1);
                }
            });

            bullets.forEach((bullet, bulletIndex) => {
                bullet.position.add(bullet.velocity);
                if (bullet.position.z > airplane.position.z + 100) {
                    scene.remove(bullet);
                    bullets.splice(bulletIndex, 1);
                }
                obstacles.forEach((obstacle, obstacleIndex) => {
                    const obstacleBox = new THREE.Box3().setFromObject(obstacle);
                    if (obstacleBox.containsPoint(bullet.position)) {
                        scene.remove(obstacle);
                        obstacles.splice(obstacleIndex, 1);
                        scene.remove(bullet);
                        bullets.splice(bulletIndex, 1);
                        createDetailedObstacle(airplane.position.z + 500);
                        destroyedObstaclesCount++;
                        document.getElementById('destroyedCount').textContent = `Obstacles Destroyed: ${destroyedObstaclesCount}`;
                    }
                });
            });

            if (!currentlyCollided) {
                airplane.position.z += FORWARD_SPEED;
                distance += FORWARD_SPEED;
                document.getElementById('score').textContent = `Distance: ${Math.floor(distance)} m`;
                document.getElementById('altitude').textContent = `Altitude: ${Math.floor(airplane.position.y)} m`;
                if (Math.floor(distance) % 500 === 0 && Math.floor(distance) > 0) {
                    createDetailedCloud(airplane.position.z + 50);
                }
            }

            airplane.position.lerp(targetPosition, MOVE_SPEED);
            const direction = new THREE.Vector3().subVectors(targetPosition, airplane.position).normalize();
            const targetQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, 1), direction);
            airplane.quaternion.slerp(targetQuaternion, 0.1);

            targetPosition.z = airplane.position.z;
            camera.position.z = airplane.position.z - 20;

            if (currentlyCollided !== isCollided) {
                isCollided = currentlyCollided;
                airplane.children[0].material.color.setHex(isCollided ? 0x888888 : 0xcccccc);
            }

            renderer.render(scene, camera);
        }

        function increaseSpeed() {
            FORWARD_SPEED *= 1.1;
        }

        function startTimer() {
            clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                timeLeft--;
                document.getElementById('timer').textContent = `Time: ${timeLeft}`;
                if (timeLeft <= 0) {
                    clearInterval(timerInterval);
                    gameOver();
                }
            }, 1000);
        }

        function gameOver() {
            gameRunning = false;
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = Math.floor(distance);
            document.getElementById('finalDestroyedCount').textContent = destroyedObstaclesCount;
        }

        function restartGame() {
            [distance, timeLeft, isCollided, destroyedObstaclesCount] = [0, 60, false, 0];
            [...obstacles, ...cloudItems, ...bullets].forEach(object => scene.remove(object));
            [obstacles, cloudItems, bullets] = [[], [], []];
            airplane.position.set(0, 10, 0);
            targetPosition.set(0, 10, 0);
            airplane.rotation.set(0, 0, 0);
            createInitialObstacles();
            ['score', 'timer', 'altitude', 'destroyedCount'].forEach(id => 
                document.getElementById(id).textContent = id === 'score' ? 'Distance: 0 m' : id === 'timer' ? 'Time: 60' : id === 'altitude' ? 'Altitude: 10 m' : 'Obstacles Destroyed: 0'
            );
            document.getElementById('gameOver').style.display = 'none';
            gameRunning = true;
            startTimer();
            animate();
        }

        function onKeyDown(event) {
            if (!gameRunning) return;
            switch(event.key) {
                case 'ArrowUp':
                    targetPosition.y = Math.min(targetPosition.y + 1, VERTICAL_RANGE);
                    break;
                case 'ArrowDown':
                    targetPosition.y = Math.max(targetPosition.y - 1, 0);
                    break;
                case 'ArrowLeft':
                    targetPosition.x = Math.min(targetPosition.x + 1, HORIZONTAL_RANGE);
                    break;
                case 'ArrowRight':
                    targetPosition.x = Math.max(targetPosition.x - 1, -HORIZONTAL_RANGE);
                    break;
                case ' ':
                    shootBullet();
                    break;
            }
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
